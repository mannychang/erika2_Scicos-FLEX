/* Code prototype for standalone use  */
/*     Generated by Code_Generation toolbox of Scicos with scicos4.4 */
/*     date : 5-Mar-2010 */

/* Copyright (c) 1989-2009 Metalau project INRIA */
/* Code generation modified by Roberto Bucher */

/* ---- Headers ---- */
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <memory.h>
#include <scicos_block4.h>
#include <machine.h>

#ifdef linux
#define __CONST__ static
#else
#define __CONST__ static const
#endif

double PJ_get_tsamp()
{
  return(0.1);
}

double PJ_get_tsamp_delay()
{
  return(0.1);
}

/* ---- Clock code ---- */
int PJ_useInternTimer(void) {
 return 1;
}

void rtextclk(void) { }

/* ---- Internals functions declaration ---- */
int PJ_init(void);
int PJ_isr(double);
int PJ_end(void);

/* prototype of 'rt_sinus' (type 4) */
void rt_sinus(scicos_block *, int );

/* prototype of 'bidon' (type 0) */
void C2F(bidon)(int *, int *, double *, double *, double *, int *, double *, \
                int *, double *, int *, double *, int *,int *, int *, \
                double *, int *, double *, int *);

/* prototype of 'flex_led' (type 4) */
void flex_led(scicos_block *, int );

/* def phase sim variable */
extern int phase;
/* block_error must be pass in argument of _sim function */
extern int *block_error;
/* block_number */
extern int block_number;

/* declaration of scicos block structures */
scicos_block block_PJ[3];

  /* Real parameters declaration */
  /* Routine name of block: rt_sinus
   * Gui name of block: FLEX_sinus
   * Compiled structure index: 1
   * Exprs: 1
   */
  static double rpar_1[]={1,1,0,0,0};

  /* Integers parameters declaration */
  /* Routine name of block: bidon
   * Gui name of block: EVTGEN_f
   * Compiled structure index: 2
   * Exprs: 1
   * ipar= {1};
   */
  static int ipar_2[]={1};



/* def real parameters */
double *RPAR[ ] = {
  rpar_1,
};

#ifdef linux
int NRPAR = 1;
int NTOTRPAR = 5;
char * strRPAR[1] = {"RPARAM[1]"};
int lenRPAR[1] = {5};
#endif

/* def integer parameters */
int *IPAR[ ] = {
  ipar_2,
};

#ifdef linux
int NIPAR = 1;
int NTOTIPAR = 1;
char * strIPAR[1] = {"IPARAM[1]"};
int lenIPAR[1] = {1};
#endif

  /* Discrete states declaration */
  /* Routine name of block: flex_led
     Gui name of block: FLEX_led
     Compiled structure index: 3
     Exprs: 
  */
  static double z_3[]={1};


  /* Work array declaration */
  static void *work_1[]={0};
  static void *work_2[]={0};
  static void *work_3[]={0};


  /* Output declaration */
  static double outtb_1[]={0};

  /* Inputs */
  static int insz_3[]={1,1,SCSREAL_N};

  static void *inptr_3[]={0};

  /* Outputs */
  static int outsz_1[]={1,1,SCSREAL_N};

  static void *outptr_1[]={0};


/*----------------------------------------  Initialisation function */
int PJ_init()
{
  double t;
  int local_flag;

  /* Affectation of inptr */
  inptr_3[0] = (void *) outtb_1;

  /* Affectation of outptr */
  outptr_1[0] = (void *) outtb_1;

  /* set blk struc. of 'rt_sinus' (type 4 - blk nb 1) */
  block_PJ[0].type    = 4;
  block_PJ[0].ztyp    = 0;
  block_PJ[0].ng      = 0;
  block_PJ[0].nz      = 0;
  block_PJ[0].nx      = 0;
  block_PJ[0].noz     = 0;
  block_PJ[0].nrpar   = 5;
  block_PJ[0].nopar   = 0;
  block_PJ[0].nipar   = 0;
  block_PJ[0].nin     = 0;
  block_PJ[0].nout    = 1;
  block_PJ[0].nevout  = 0;
  block_PJ[0].nmode   = 0;
  block_PJ[0].outptr  = outptr_1;
  block_PJ[0].outsz   = outsz_1;
  block_PJ[0].rpar    = rpar_1;
  block_PJ[0].work    = work_1;

  /* set blk struc. of 'flex_led' (type 4 - blk nb 3) */
  block_PJ[2].type    = 4;
  block_PJ[2].ztyp    = 0;
  block_PJ[2].ng      = 0;
  block_PJ[2].nz      = 1;
  block_PJ[2].nx      = 0;
  block_PJ[2].noz     = 0;
  block_PJ[2].nrpar   = 0;
  block_PJ[2].nopar   = 0;
  block_PJ[2].nipar   = 0;
  block_PJ[2].nin     = 1;
  block_PJ[2].nout    = 0;
  block_PJ[2].nevout  = 0;
  block_PJ[2].nmode   = 0;
  block_PJ[2].inptr   = inptr_3;
  block_PJ[2].insz    = insz_3;
  block_PJ[2].z       = z_3;
  block_PJ[2].work    = work_3;

  /* set initial phase simulation */
  phase = 1;

  /* Initialization */

  /* Call of 'rt_sinus' (type 4 - blk nb 1) */
  block_PJ[0].nevprt = 0;
  local_flag = 4;
  set_block_number(1);
  rt_sinus(&block_PJ[0],local_flag);

  /* Call of 'flex_led' (type 4 - blk nb 3) */
  block_PJ[2].nevprt = 0;
  local_flag = 4;
  set_block_number(3);
  flex_led(&block_PJ[2],local_flag);
  return(local_flag);
}

/*----------------------------------------  ISR function */
int PJ_isr(double t)
{
  int local_flag;
  int i;
    /* Output computation */
    /* Discrete activations */
    /* Call of 'rt_sinus' (type 4 - blk nb 1) */
    block_PJ[0].nevprt = 1;
    local_flag = 1;
    set_block_number(1);
    rt_sinus(&block_PJ[0],local_flag);

    /* Call of 'flex_led' (type 4 - blk nb 3) */
    block_PJ[2].nevprt = 1;
    local_flag = 1;
    set_block_number(3);
    flex_led(&block_PJ[2],local_flag);



    /* Discrete state computation */
    /* Discrete activations */
    /* Call of 'rt_sinus' (type 4 - blk nb 1) */
    block_PJ[0].nevprt = 1;
    local_flag = 2;
    set_block_number(1);
    rt_sinus(&block_PJ[0],local_flag);

    /* Call of 'flex_led' (type 4 - blk nb 3) */
    block_PJ[2].nevprt = 1;
    local_flag = 2;
    set_block_number(3);
    flex_led(&block_PJ[2],local_flag);




  return 0;
}
/*----------------------------------------  Termination function */
int PJ_end()
{
  double t;
  int local_flag;

  /* Ending */

  /* Call of 'rt_sinus' (type 4 - blk nb 1) */
  block_PJ[0].nevprt = 0;
  local_flag = 5;
  set_block_number(1);
  rt_sinus(&block_PJ[0],local_flag);

  /* Call of 'flex_led' (type 4 - blk nb 3) */
  block_PJ[2].nevprt = 0;
  local_flag = 5;
  set_block_number(3);
  flex_led(&block_PJ[2],local_flag);
  return 0;
}

