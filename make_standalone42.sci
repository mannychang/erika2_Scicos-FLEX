
//==========================================================================
//generates code of the standalone simulation procedure
//
//Copyright INRIA
//
// rmq : La fonction zdoit n'est pas utilisï¿½e pour le moment

// Original file from Project Metalau - INRIA
// Modified for RT purposes by Roberto Bucher - RTAI Team
// roberto.bucher@supsi.ch

function [Code,Code_common]=make_standalone42()

  x=cpr.state.x;
  modptr=cpr.sim.modptr;
  rpptr=cpr.sim.rpptr;
  ipptr=cpr.sim.ipptr;
  opptr=cpr.sim.opptr;
  rpar=cpr.sim.rpar;
  ipar=cpr.sim.ipar;
  opar=cpr.sim.opar;
  oz=cpr.state.oz;
  ordptr=cpr.sim.ordptr;
  oord=cpr.sim.oord;
  zord=cpr.sim.zord;
  iord=cpr.sim.iord;
  tevts=cpr.state.tevts;
  evtspt=cpr.state.evtspt;
  zptr=cpr.sim.zptr;
  clkptr=cpr.sim.clkptr;
  ordptr=cpr.sim.ordptr;
  pointi=cpr.state.pointi;
  funs=cpr.sim.funs;
  noord=size(cpr.sim.oord,1);
  nzord=size(cpr.sim.zord,1);
  niord=size(cpr.sim.iord,1);

  Indent='  ';
  Indent2=Indent+Indent;
  BigIndent='          ';

  work=zeros(nblk,1)
  Z=[z;zeros(lstsize(outtb),1);work]';
  nX=size(x,'*');
  nztotal=size(z,1);

  stalone = %t;

  Code=['/* Code prototype for standalone use  */'
        '/*     Generated by Code_Generation toolbox of Scicos with '+ ..
        getversion()+' */'
        '/*     date : '+date()+' */'
        ''
        '/* ---- Headers ---- */'
        '#include <stdlib.h>'
        '#include <math.h>'
        '#include <string.h>'
        '#include <memory.h>'
        '#include <scicos_block4.h>'
        '#include <machine.h>'
        ''
	'#ifdef linux'
	'#define __CONST__'
	'#else'
	'#define __CONST__ static const'
	'#endif'
	''
	'double '+rdnom+'_get_tsamp()'
	'{'
	'  return(' + string(Tsamp) + ');'
	'}'
	''
	'double '+rdnom+'_get_tsamp_delay()'
	''
        '{'
	'  return(' + string(Tsamp_delay) + ');'
	'}'
	''
        '/* ---- Internals functions declaration ---- */'
        'int '+rdnom+'_init(void);'
        'int '+rdnom+'_isr(double);'
        'int '+rdnom+'_end(void);'
        Protostalone
        '']

  if x<>[] then
    Code=[Code
          '/* Code prototype for standalone use  */'
          'int C2F('+rdnom+'simblk)(double , double *, double *);'
          'extern  int C2F(dset)();'
          'static int ode1();'
          'static int ode2();'
          'static int ode4();'
          '']
  end

  Code=[Code;
        ''
        '/* Some general static variables */'
        'static double zero=0;'
        'static double w[1];'
        'void **'+rdnom+'_block_outtbptr;'] //** !!

  Code=[Code;
        make_static_standalone42()]

  Code=[Code
        '  /* Initial values */'
        ''
        '  /* Note that z[]=[z_initial_condition;outtbptr;work]'
        cformatline('     z_initial_condition={'+...
          strcat(string(z),",")+'};',70)
        cformatline('     outtbptr={'+...
          strcat(string(zeros(lstsize(outtb),1)),"," )+'};',70)
        cformatline('     work= {'+...
          strcat(string(work),"," )+'};',70)
        '  */'
        ''
        cformatline('  static double z[]={'+strcat(string(Z),',')+'};',70)
       '']

  //** declaration of outtb
  Code_outtb = [];
  for i=1:lstsize(outtb)
    if mat2scs_c_nb(outtb(i)) <> 11 then
      Code_outtb=[Code_outtb;
                  cformatline('  static '+mat2c_typ(outtb(i))+...
                              ' outtb_'+string(i)+'[]={'+...
                              strcat(string(outtb(i)(:)),',')+'};',70)]
    else //** cmplx test
      Code_outtb=[Code_outtb;
                  cformatline('  static '+mat2c_typ(outtb(i))+...
                              ' outtb_'+string(i)+'[]={'+...
                              strcat(string([real(outtb(i)(:));
                                             imag(outtb(i)(:))]),',')+'};',70)]
    end
  end
  Code=[Code;
        Code_outtb;
        '']

// Bubu modified

  Code1 = []

  Code2=[''
        '/*'+part('-',ones(1,40))+'  Initialisation function */'
        'int '+rdnom+'_init()'
        '{'
	'  double t;'
        '  int local_flag;'
//	'#ifdef linux'
//        '  double *args[2];'
//	'#endif'
        '']


  if size(z,1) <> 0 then
    for i=1:(length(zptr)-1)
      if zptr(i+1)-zptr(i)>0 then
        if size(corinv(i),'*')==1 then
          OO=scs_m.objs(corinv(i))
        else
          path=list('objs')
          for l=cpr.corinv(i)(1:$-1)
            path($+1)=l;path($+1)='model'
            path($+1)='rpar'
            path($+1)='objs'
          end
          path($+1)=cpr.corinv(i)($)
          OO=scs_m(path)
        end
        aaa=OO.gui
        bbb=emptystr(3,1);
        if and(aaa+bbb~=['INPUTPORTEVTS';'OUTPUTPORTEVTS';'EVTGEN_f']) then
          Code2($+1)='';
          Code2($+1)=' /* Routine name of block: '+strcat(string(cpr.sim.funs(i)));
          Code2($+1)='    Gui name of block: '+strcat(string(OO.gui));
          //Code2($+1)='/* Name block: '+strcat(string(cpr.sim.funs(i)));
          //Code2($+1)='Object number in diagram: '+strcat(string(cpr.corinv(i)));
          Code2($+1)='   Compiled structure index: '+strcat(string(i));
          if stripblanks(OO.model.label)~=emptystr() then
            Code2=[Code2;
                   cformatline('   Label: '+strcat(string(OO.model.label)),70)]
          end
          if stripblanks(OO.graphics.exprs(1))~=emptystr() then
            Code2=[Code2;
                   cformatline('   Exprs: '+strcat(OO.graphics.exprs(1),","),70)]
          end
          if stripblanks(OO.graphics.id)~=emptystr() then
            Code2=[Code2;
                   cformatline('   Identification: '+..
                     strcat(string(OO.graphics.id)),70)]
          end
          Code2=[Code2;
                 cformatline('   z={'+...
                 strcat(string(z(zptr(i):zptr(i+1)-1)),",")+'};',70)]
          Code2($+1)=' */';
        end
      end
    end
  end

  //** declaration of oz
  Code_oz = [];
  for i=1:lstsize(oz)
    if mat2scs_c_nb(oz(i)) <> 11 then
      Code_oz=[Code_oz;
               cformatline('  '+mat2c_typ(oz(i))+...
                           ' oz_'+string(i)+'[]={'+...
                           strcat(string(oz(i)(:)),',')+'};',70)]
    else //** cmplx test
      Code_oz=[Code_oz;
               cformatline('  '+mat2c_typ(oz(i))+...
                           ' oz_'+string(i)+'[]={'+...
                           strcat(string([real(oz(i)(:));
                                          imag(oz(i)(:))]),',')+'};',70)]
    end
  end

  if Code_oz <> [] then
    Code2=[Code2;
           '  /* oz declaration */'
           Code_oz]
  end

  Code2=[Code2
         '  /* Get work ptr of blocks */'
         '  void **work;'
         '  work = (void **)(z+'+string(size(z,'*')+lstsize(outtb))+');'
         '']


  if Code_outtb<>[] then
    Code2=[Code2
           '  /* outtbptr declaration */'
           '  '+rdnom+'_block_outtbptr = (void **)(z+'+string(nztotal)+');'
           '']
  end

  Code_outtbptr=[];
  for i=1:lstsize(outtb)
    Code_outtbptr=[Code_outtbptr;
                   '  '+rdnom+'_block_outtbptr['+...
                    string(i-1)+'] = (void *) outtb_'+string(i)+';'];
  end

  if Code_outtbptr<>[] then
    Code2=[Code2;
           Code_outtbptr
           '']
  end

  for kf=1:nblk
    nx=xptr(kf+1)-xptr(kf);       //** number of continuous state
    nin=inpptr(kf+1)-inpptr(kf);  //** number of input ports
    nout=outptr(kf+1)-outptr(kf); //** number of output ports

    //** add comment
    txt=[get_comment('set_blk',list(funs(kf),funtyp(kf),kf));]

    Code2=[Code2;
           '  '+txt];

    flex_ng     = zcptr(kf+1)-zcptr(kf);
    flex_nz     = zptr(kf+1)-zptr(kf);
    flex_noz    = ozptr(kf+1)-ozptr(kf);
    flex_nin    = inpptr(kf+1)-inpptr(kf);
    flex_nout   = outptr(kf+1)-outptr(kf);
    flex_nevout = clkptr(kf+1)-clkptr(kf);
    flex_nopar  = opptr(kf+1)-opptr(kf);

    Code2=[Code2;
           '  block_'+rdnom+'['+string(kf-1)+'].type   = '+string(funtyp(kf))+';';
           '  block_'+rdnom+'['+string(kf-1)+'].ztyp   = '+string(ztyp(kf))+';';
           '  block_'+rdnom+'['+string(kf-1)+'].ng     = '+string(flex_ng)+';';
           '  block_'+rdnom+'['+string(kf-1)+'].nz     = '+string(flex_nz)+';';
           '  block_'+rdnom+'['+string(kf-1)+'].noz    = '+string(flex_noz)+';';
           '  block_'+rdnom+'['+string(kf-1)+'].nrpar  = '+string(rpptr(kf+1)-rpptr(kf))+';';
           '  block_'+rdnom+'['+string(kf-1)+'].nopar  = '+string(flex_nopar)+';';
           '  block_'+rdnom+'['+string(kf-1)+'].nipar  = '+string(ipptr(kf+1)-ipptr(kf))+';'
           '  block_'+rdnom+'['+string(kf-1)+'].nin    = '+string(flex_nin)+';';
           '  block_'+rdnom+'['+string(kf-1)+'].nout   = '+string(flex_nout)+';';
           '  block_'+rdnom+'['+string(kf-1)+'].nevout = '+string(flex_nevout)+';';
           '  block_'+rdnom+'['+string(kf-1)+'].nmode  = '+string(modptr(kf+1)-modptr(kf))+';';]

    if nx <> 0 then
      Code2=[Code2;
             '  block_'+rdnom+'['+string(kf-1)+'].nx = '+string(nx)+';';
             '  block_'+rdnom+'['+string(kf-1)+'].x  = &(x['+string(xptr(kf)-1)+']);'
             '  block_'+rdnom+'['+string(kf-1)+'].xd = &(xd['+string(xptr(kf)-1)+']);']
    end

    if flex_nevout <> 0 then
      flex_str = rdnom +'_'+string(kf-1)+'_evout'
      Code1=[Code1;
             'double '+flex_str+'['+string(flex_nevout)+'];'
            ]
      Code2=[Code2;
             '  block_'+rdnom+'['+string(kf-1)+'].evout = '+flex_str+';';
            ];
    end

    //***************************** input port *****************************//
    if flex_nin <> 0 then
      flex_str = rdnom +'_'+string(kf-1)+'_inptr'
      Code1=[Code1;
             'double * '+flex_str+'['+string(flex_nin)+'];'
            ]
      Code2=[Code2;
             '  block_'+rdnom+'['+string(kf-1)+'].inptr = '+flex_str+';';
            ];
      flex_str = rdnom +'_'+string(kf-1)+'_insz'

      Code2=[Code2;
             '  block_'+rdnom+'['+string(kf-1)+'].insz = '+flex_str+';';
            ];

      //** inptr **//
      for k=1:nin
         lprt=inplnk(inpptr(kf)-1+k);
         Code2=[Code2
                '  block_'+rdnom+'['+string(kf-1)+'].inptr['+string(k-1)+...
                ']  = '+rdnom+'_block_outtbptr['+string(lprt-1)+'];']
      end

      //** 1st dim **//
      szCode='const int '+flex_str+'['+string(3*flex_nin)+']={'
      for k=1:nin
         lprt=inplnk(inpptr(kf)-1+k);
         szCode=szCode+string(size(outtb(lprt),1))+','
      end

      //** 2dn dim **//
      for k=1:nin
         lprt=inplnk(inpptr(kf)-1+k);
         szCode=szCode+string(size(outtb(lprt),2))+','
      end

      //** typ **//
      for k=1:nin
         lprt=inplnk(inpptr(kf)-1+k);
         szCode=szCode+mat2scs_c_typ(outtb(lprt))+','
      end
      szCode=part(szCode,1:length(szCode)-1)+'};'
      Code1=[Code1;
	     szCode;
	    ]
    end
    
    //***************************** output port *****************************//
    if flex_nout <> 0 then
      flex_str = rdnom +'_'+string(kf-1)+'_outptr'
      Code1=[Code1;
             'double * '+flex_str+'['+string(flex_nout)+'];'
            ]
      Code2=[Code2;
             '  block_'+rdnom+'['+string(kf-1)+'].outptr = '+flex_str+';';
            ];
      flex_str = rdnom +'_'+string(kf-1)+'_outsz'
      Code2=[Code2;
             '  block_'+rdnom+'['+string(kf-1)+'].outsz = '+flex_str+';';
            ];

      //** outptr **//
      for k=1:nout
         lprt=outlnk(outptr(kf)-1+k);
         Code2=[Code2
                '  block_'+rdnom+'['+string(kf-1)+'].outptr['+string(k-1)+...
                '] = '+rdnom+'_block_outtbptr['+string(lprt-1)+'];']
      end

      //** 1st dim **//
      szCode='const int '+flex_str+'['+string(3*flex_nout)+']={'
      for k=1:nout
         lprt=outlnk(outptr(kf)-1+k);
         szCode=szCode+string(size(outtb(lprt),1))+','
      end

      //** 2dn dim **//
      for k=1:nout
         lprt=outlnk(outptr(kf)-1+k);
         szCode=szCode+string(size(outtb(lprt),2))+','
      end

      //** typ **//
      for k=1:nout
         lprt=outlnk(outptr(kf)-1+k);
         szCode=szCode+mat2scs_c_typ(outtb(lprt))+','
      end
      szCode=part(szCode,1:length(szCode)-1)+'};'
      Code1=[Code1;
	     szCode;
	    ]    
    end

    //**********************************************************************//
    Code2=[Code2
           '  block_'+rdnom+'['+string(kf-1)+...
           '].z = &(z['+string(zptr(kf)-1)+']);']

    if (part(funs(kf),1:7) ~= 'capteur' &...
        part(funs(kf),1:10) ~= 'actionneur' &...
        funs(kf) ~= 'bidon') then
      //** rpar **//
      if (rpptr(kf+1)-rpptr(kf)>0) then
        Code2=[Code2;
               '  block_'+rdnom+'['+string(kf-1)+...
               '].rpar=&(RPAR['+string(rpptr(kf)-1)+']);']
      end
      //** ipar **//
      if (ipptr(kf+1)-ipptr(kf)>0) then
        Code2=[Code2;
               '  block_'+rdnom+'['+string(kf-1)+...
               '].ipar=&(IPAR['+string(ipptr(kf)-1)+']);']
      end

      //**********************************************************************//
      //** opar **//

      if flex_nopar<> 0 then
        flex_str = rdnom +'_'+string(kf-1)+'_oparptr'
        Code1=[Code1;
               'void * '+flex_str+'['+string(flex_nopar)+'];'
            ]
        Code2=[Code2;
               '  block_'+rdnom+'['+string(kf-1)+'].oparptr = '+flex_str+';';
              ];

        flex_str = rdnom +'_'+string(kf-1)+'_oparsz'
        Code2=[Code2;
               '  block_'+rdnom+'['+string(kf-1)+'].oparsz = '+flex_str+';';
              ];

        flex_str = rdnom +'_'+string(kf-1)+'_opartyp'
        Code2=[Code2;
               '  block_'+rdnom+'['+string(kf-1)+'].opartyp = '+flex_str+';';
              ];

        nopar = flex_nopar;
        //** oparptr **//
        for k=1:nopar
          Code2=[Code2;
                 '  block_'+rdnom+'['+string(kf-1)+'].oparptr['+string(k-1)+...
                 ']   = (void *) OPAR_'+string(opptr(kf)-1+k)+';'];
        end
        //** 1st dim **//
	szCode='const int '+rdnom+'_'+string(kf-1)+'_oparsz['+string(2*flex_nopar)+']={';
        for k=1:nopar
           szCode=szCode+string(size(opar(opptr(kf)-1+k),1))+',';
        end
        //** 2dn dim **//
        for k=1:nopar
           szCode=szCode+string(size(opar(opptr(kf)-1+k),2))+',';
        end
        szCode=part(szCode,1:length(szCode)-1)+'};'
        Code1=[Code1;
	       szCode;
	      ]    

        //** typ **//
	szCode='const int '+rdnom+'_'+string(kf-1)+'_opartyp['+string(flex_nopar)+']={';
        for k=1:nopar
           szCode=szCode+mat2scs_c_typ(opar(opptr(kf)-1+k))+',';
        end
        szCode=part(szCode,1:length(szCode)-1)+'};'
        Code1=[Code1;
	       szCode;
	      ]    
      end

      //**********************************************************************//
      //** oz **//
      if flex_noz>0 then
        noz = flex_noz;
        flex_str = rdnom +'_'+string(kf-1)+'_ozptr'
        Code1=[Code1;
               'void * '+flex_str+'['+string(flex_noz)+'];'
            ]
        Code2=[Code2;
               '  block_'+rdnom+'['+string(kf-1)+'].ozptr = '+flex_str+';';
              ];

        flex_str = rdnom +'_'+string(kf-1)+'_ozsz'
        Code2=[Code2;
               '  block_'+rdnom+'['+string(kf-1)+'].ozsz = '+flex_str+';';
              ];

        flex_str = rdnom +'_'+string(kf-1)+'_oztyp'
        Code2=[Code2;
               '  block_'+rdnom+'['+string(kf-1)+'].oztyp = '+flex_str+';';
              ];

        //** ozptr **//
        for k=1:noz
          Code2=[Code2;
                 '  block_'+rdnom+'['+string(kf-1)+'].ozptr['+string(k-1)+...
                 ']   = (void *) oz_'+string(ozptr(kf)-1+k)+';'];
        end
        //** 1st dim **//
	szCode='const int '+rdnom+'_'+string(kf-1)+'_ozsz['+string(2*flex_noz)+']={';
        for k=1:noz
           szCode=szCode+string(size(oz(ozptr(kf)-1+k),1))+',';
        end
        //** 2dn dim **//
        for k=1:noz
           szCode=szCode+string(size(oz(ozptr(kf)-1+k),2))+',';
        end
        szCode=part(szCode,1:length(szCode)-1)+'};'
        Code1=[Code1;
	       szCode;
	      ]    

        //** typ **//
	szCode='int '+rdnom+'_'+string(kf-1)+'_oztyp['+string(flex_noz)+']={';
        for k=1:noz
           szCode=szCode+mat2scs_c_typ(oz(ozptr(kf)-1+k))+',';
        end
        szCode=part(szCode,1:length(szCode)-1)+'};'
        Code1=[Code1;
	       szCode;
	      ]    
      end
    end
    Code2=[Code2;
           '  block_'+rdnom+'['+string(kf-1)+'].work = '+...
           '(void **)(((double *)work)+'+string(kf-1)+');']
  end

  //** init
  Code=[Code;
        Code1;
        Code2;
        '   '+get_comment('flag',list(4))]

  for kf=1:nblk
//    if or(kf==act) | or(kf==cap) then
//        txt = call_block42(kf,0,4);
//        if txt <> [] then
//          Code=[Code;
//                '';
//                '  '+txt];
//        end
//    else
      txt = call_block42(kf,0,4);
      if txt <> [] then
        Code=[Code;
              '';
              '  '+txt];
      end
//    end
  end

  //** cst blocks and it's dep
  txt=write_code_idoit()

  if txt<>[] then
    Code=[Code;
          ''
          '    /* Initial blocks must be called with flag 1 */'
          txt]
  end
  Code=[Code;
	'  return(local_flag);'
	'}'];

  Code=[Code;
        ''
        '/*'+part('-',ones(1,40))+'  ISR function */'
        'int '+rdnom+'_isr(double t)'
        '{'
//        '  int nevprt=1;'
        '  int local_flag;'
	'  int i;'
//	'#ifdef linux'
//        '  double *args[2];'
//	'#endif'
       ]

  if (x <> []) then
    Code=[Code
          '  double tout, dt, he, h;'
          '']
  end

  //** find source activation number
  blks=find(funtyp>-1);
  evs=[];

  for blk=blks
    for ev=clkptr(blk):clkptr(blk+1)-1
      if funs(blk)=='bidon' then
        if ev > clkptr(howclk) -1
         evs=[evs,ev];
        end
      end
    end
  end

  //** flag 1,2,3
  for flag=[1,2,3]

    txt3=[]

    //** continuous time blocks must be activated
    //** for flag 1
    if flag==1 then
      txt = write_code_cdoit(flag);

      if txt <> [] then
        txt3=[''
              '  '+get_comment('ev',list(0))
              txt;
             ];
      end
    end

    //** blocks with input discrete event must be activated
    //** for flag 1, 2 and 3
    if size(evs,2)>=1 then
      txt4=[]
      //**
      for ev=evs
        txt2=write_code_doit(ev,flag);
        if txt2<>[] then
          //** adjust event number because of bidon block
          new_ev=ev-(clkptr(howclk)-1)
          //**
          txt4=[txt4;
//                Indent+['case '+string(new_ev)+' : '+...
//                get_comment('ev',list(new_ev))
                Indent+[get_comment('ev',list(new_ev))
                txt2];
//                '    break;';
		'']
        end
      end

      //**
      if txt4 <> [] then
        txt3=[txt3;
              Indent+'/* Discrete activations */'
//              Indent+'switch (nevprt) {'
              txt4
//              '  }'
             ];
      end
    end

    //**
    if txt3<>[] then
      Code=[Code;
            '  '+get_comment('flag',list(flag))
            txt3];
    end
  end

  if x<>[] then
    Code=[Code
          ''
          '  tout=t;'
	  '  dt='+rdnom+'_get_tsamp();'
          '  h=dt/'+odestep+';' 
          '  while (tout+h<t+dt){'
          '    '+odefun+'(C2F('+rdnom+'simblk),tout,h);'
          '     tout=tout+h;'
          '  }'
          ''
          '  he=t+dt-tout;'
          '  '+odefun+'(C2F('+rdnom+'simblk),tout,he);'
          '']
  end

  //** fix bug provided by Roberto Bucher
  //** Alan, 13/10/07
  if nX <> 0 then
    Code=[Code;
          ''
          '    /* update ptrs of continuous array */']
    for kf=1:nblk
      nx=xptr(kf+1)-xptr(kf);  //** number of continuous state
      if nx <> 0 then
        Code=[Code;
              '  block_'+rdnom+'['+string(kf-1)+'].nx = '+...
               string(nx)+';';
              '  block_'+rdnom+'['+string(kf-1)+'].x  = '+...
               '&(x['+string(xptr(kf)-1)+']);'
              '  block_'+rdnom+'['+string(kf-1)+'].xd = '+...
               '&(xd['+string(xptr(kf)-1)+']);']
      end
    end
  end

  Code=[Code
	''
	'  return 0;'
        '}']

  //** flag 5

  Code=[Code
        '/*'+part('-',ones(1,40))+'  Termination function */'
        'int '+rdnom+'_end()'
        '{'
	'  double t;'
        '  int local_flag;'
//	'#ifdef linux'
//        '  double *args[2];'
//	'#endif'
        '']

  Code=[Code;
        '  '+get_comment('flag',list(5))]

  for kf=1:nblk
//    if or(kf==act) | or(kf==cap) then
//        txt = call_block42(kf,0,5);
//        if txt <> [] then
//          Code=[Code;
//                '';
//                '  '+txt];
//        end
//    else
      txt = call_block42(kf,0,5);
      if txt <> [] then
        Code=[Code;
              '';
              '  '+txt];
      end
//    end
  end

  Code=[Code
        '  return 0;'
        '}'
	'']

  Code_common=['/* Code prototype for common use  */'
               '/*     Generated by Code_Generation toolbox of Scicos with '+ ..
                getversion()+' */'
               '/*     date : '+date()+' */'
               ''
               '/* ---- Headers ---- */'
               '#include <memory.h>'
               '#include '"machine.h'"'
               ''
               'void set_block_error(int err)'
               '{'
               '  return;'
               '}'
               ''
               'int get_phase_simulation()'
               '{'
               '  return 1;'
               '}'
               ''
               'void * scicos_malloc(size_t size)'
               '{'
               '  return malloc(size);'
               '}'
               ''
               'void scicos_free(void *p)'
               '{'
               '  free(p);'
               '}'
               ''
               'void do_cold_restart()'
               '{'
               '  return;'
               '}'
               ''
               'void sciprint (char *fmt)'
               '{'
               '  return;'
               '}'
               '']

  if (x <> []) then
    Code=[Code;
          'int C2F('+rdnom+'simblk)(t, xc, xdc)'
          ''
          '   double t, *xc, *xdc;'
          ''
          '     /*'
          '      *  !purpose'
          '      *  compute state derivative of the continuous part'
          '      *  !calling sequence'
          '      *  neq   : integer the size of the  continuous state'
          '      *  t     : current time'
          '      *  xc    : double precision vector whose contains the continuous state'
          '      *  xdc   : double precision vector, contain the computed derivative'
          '      *  of the state'
          '      */'
          '{'
          '  int phase=2;'
          '  int local_flag;'
          '  int nport;'
//          '  int nevprt=1;'
//	  '#ifdef linux'
//          '  double *args[2];'
//	  '#endif'
          '  C2F(dset)(&neq, &c_b14,xd , &c__1);'
          '']

    Code=[Code;
          '    '+get_comment('update_xd',list())]

    for kf=1:nblk
      if (xptr(kf+1)-xptr(kf)) > 0 then
        Code=[Code;
              '    block_'+rdnom+'['+string(kf-1)+'].x='+...
                '&(xc['+string(xptr(kf)-1)+']);'
              '    block_'+rdnom+'['+string(kf-1)+'].xd='+...
                '&(xdc['+string(xptr(kf)-1)+']);']
      end
    end

    Code=[Code;
          ''
          write_code_odoit(1)
          write_code_odoit(0)
         ]

    for kf=1:nblk
      if (xptr(kf+1)-xptr(kf)) > 0 then
        Code=[Code;
              '    block_'+rdnom+'['+string(kf-1)+'].x='+...
                '&(x['+string(xptr(kf)-1)+']);'
              '    block_'+rdnom+'['+string(kf-1)+'].xd='+...
                '&(xd['+string(xptr(kf)-1)+']);']
      end
    end

    Code=[Code
          ''
          '  return 0;'
          '}'
          ''
          '/* Euler''s Method */'
          'static int ode1(f,t,h)'
          '  int (*f) ();'
          '  double t, h;'
          '{'
          '  int i;'
          ''
          '  /**/'
          '  (*f)(t,x, xd);'
          ''
          '  for (i=0;i<neq;i++) {'
          '   x[i]=x[i]+h*xd[i];'
          '  }'
          ''
          '  return 0;'
          '}'
          ''
          '/* Heun''s Method */'
          'static int ode2(f,t,h)'
          '  int (*f) ();'
          '  double t, h;'
          '{'
          '  int i;'
          '  double y['+string(nX)+'],yh['+string(nX)+'],temp,f0['+string(nX)+'],th;'
          ''
          '  /**/'
          '  memcpy(y,x,neq*sizeof(double));'
          '  memcpy(f0,xd,neq*sizeof(double));'
          ''
          '  /**/'
          '  (*f)(t,y, f0);'
          ''
          '  /**/'
          '  for (i=0;i<neq;i++) {'
          '    x[i]=y[i]+h*f0[i];'
          '  }'
          '  th=t+h;'
          '  for (i=0;i<neq;i++) {'
          '    yh[i]=y[i]+h*f0[i];'
          '  }'
          '  (*f)(th,yh, xd);'
          ''
          '  /**/'
          '  temp=0.5*h;'
          '  for (i=0;i<neq;i++) {'
          '    x[i]=y[i]+temp*(f0[i]+xd[i]);'
          '  }'
          ''
          '  return 0;'
          '}'
          ''
          '/* Fourth-Order Runge-Kutta (RK4) Formula */'
          'static int ode4(f,t,h)'
          '  int (*f) ();'
          '  double t, h;'
          '{'
          '  int i;'
          '  double y['+string(nX)+'],yh['+string(nX)+'],'+...
            'temp,f0['+string(nX)+'],th,th2,'+...
            'f1['+string(nX)+'],f2['+string(nX)+'];'
          ''
          '  /**/'
          '  memcpy(y,x,neq*sizeof(double));'
          '  memcpy(f0,xd,neq*sizeof(double));'
          ''
          '  /**/'
          '  (*f)(t,y, f0);'
          ''
          '  /**/'
          '  for (i=0;i<neq;i++) {'
          '    x[i]=y[i]+h*f0[i];'
          '  }'
          '  th2=t+h/2;'
          '  for (i=0;i<neq;i++) {'
          '    yh[i]=y[i]+(h/2)*f0[i];'
          '  }'
          '  (*f)(th2,yh, f1);'
          ''
          '  /**/'
          '  temp=0.5*h;'
          '  for (i=0;i<neq;i++) {'
          '    x[i]=y[i]+temp*f1[i];'
          '  }'
          '  for (i=0;i<neq;i++) {'
          '    yh[i]=y[i]+(h/2)*f1[i];'
          '  }'
          '  (*f)(th2,yh, f2);'
          ''
          '  /**/'
          '  for (i=0;i<neq;i++) {'
          '    x[i]=y[i]+h*f2[i];'
          '  }'
          '  th=t+h;'
          '  for (i=0;i<neq;i++) {'
          '    yh[i]=y[i]+h*f2[i];'
          '  }'
          '  (*f)(th2,yh, xd);'
          ''
          '  /**/'
          '  temp=h/6;'
          '  for (i=0;i<neq;i++) {'
          '    x[i]=y[i]+temp*(f0[i]+2.0*f1[i]+2.0*f2[i]+xd[i]);'
          '  }'
          ''
          'return 0;'
          '}']
  end
endfunction
